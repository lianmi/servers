syntax = "proto3";
package cc.lianmi.im.msg;
option go_package = "github.com/lianmi/servers/api/proto/msg";
import "Auth.proto";
import "MsgTypeEnum.proto";
// 聊天模块
// 消息类型


message MessageAttach {
    AttachType type = 1; // 附件类型
    bytes attach = 2; //　附件内容信息 AttachImage 等 序列化后 放入这里
}

// 应用层使用消息数据包 处理生成应用层的 数据包
// 消息数据包
message MessagePackage {
    // 消息的传输场景
    MessageScene scene = 1;
    // 消息类型
    MessageType type = 2;
    // 消息id 服务器生成 全局唯一
    string msgid = 3;
    // 客户端生成的uuid
    string uuid = 4;
    // 消息序号
    fixed64 seq = 5;
    // 消息状态 bitset 方式储存
    // 第一位是 已读未读 状态
    // 第二位是 撤销 状态(即让不让 ui 显示 , 且改消息 撤回状态 为1 ,body 清空 客户端不让显示 )
    int32 status=6;
    // 消息的发送方
    string from = 7;
    // 消息的接受方
    string to = 8;
    // 消息负载
    bytes body = 9;
    //对方客户端发送时间,Unix时间戳
    //是否必填-是
    fixed64 userUpdateTime = 10;
    //服务器处理消息时间，Unix时间戳
    //是否必填-是
    fixed64 time = 11;
}

//2.6.11. 拉取历史消息
message ReadMessageHistorysReq{
    //会话ID
    //是否必填-是
    string sessionId=1;
    //读取消息起始消息Id(对应消息结构IdServer字段)
    //是否必填-是
    string maxId=2;
    //读取消息数量
    //取值范围1～200
    //是否必填-是
    fixed32 limit=3;
    //查询方向
    //是否必填-是
    //true 正序，查询比锚点时间更晚的消息
    //false 反序，查询比锚点时间更早的消息
    bool direction=4;
}

message ReadMessageHistorysRsp{
    //消息列表
    //是否必填-是
    repeated MessagePackage msgs=1;
}

// 发送消息

message SendMsgReq {
    //传输场景
    //是否必填-是
    MessageScene scene = 1;
    //消息类型
    //是否必填-是
    MessageType type=2;
    //接收人ID
    //是否必填-是
    string to=3;
    //客户端分配的消息ID，SDK生成的消息id,
    //在发送消息之后会返回给开发者,
    //开发者可以在发送消息的结果回调里面根据这个ID来判断相应消息的发送状态,
    //到底是发送成功了还是发送失败了, 然后根据此状态来更新页面的UI。
    //如果发送失败, 那么可以重新发送此消息，推荐UUID
    //是否必填-是
    string uuid=4;
    //用于UI展示的文本信息
    //是否必填-否
    bytes body=5;
    //客户端发送时间,Unix时间戳
    //是否必填-是
    fixed64 userUpdateTime=6;
    //指定该消息接收设备(to登录的任一设备)
    //是否必填-否
    string toDeviceId=7;
}

//发送消息响应
message SendMsgRsp{
    //消息客户端ID
    //是否必填-是
    string uuid=1;
    //消息服务器ID
    //是否必填-是
    string msgid=2;
    //消息序号，单个会话内自然递增
    //是否必填-是
    fixed64 seq=3;
    //消息服务器处理时间,Unix时间戳
    //是否必填-是
    fixed64 time=4;
}



//私聊接收消息
//服务器将从from端接收到的消息转发给to端
//api类型-EVENT
message RecvMsgEvent {
    //传输场景，固定为 C2C或P2P
    //是否必填-是
    MessageScene scene = 1;
    //消息类型
    //是否必填-是
    MessageType type=2;
    //接受消息事件的内容 , 更具 type 选择处理方式
    //是否必填-否
    bytes body=3;
    //消息来源,用户ID
    //是否必填-是
    string from=4;
    //发消息，用户昵称
    //是否必填-是
    string fromNick=5;
    //发送方消息设备ID
    //是否必填-是
    string fromDeviceId=6;
    //服务器分配的消息ID
    //是否必填-是
    string msgid=7;
    //消息序号，单个会话内自然递增
    //是否必填-是
    fixed64 seq=8;
    //客户端分配的消息ID，SDK生成的消息id,
    //在发送消息之后会返回给开发者, 开发者可以在发送消息
    //的结果回调里面根据这个ID来判断相应消息的发送状态,
    //到底是发送成功了还是发送失败了, 然后根据此状态来
    //更新页面的UI。如果发送失败, 那么可以重新发送此消息，推荐UUID
    //是否必填-是
    string uuid=9;
    //服务器处理消息时间，Unix时间戳
    //是否必填-是
    fixed64 time=10;

}
// 消息事件 推送是通知的时候 的数据体
message MessageNotification{
    // 通知的时候 body 的二进制内容

    //消息来源设备类型,参考登录指令
    //是否必填-是
    auth.ClientType fromClientType=4;

    //推送通知栏显示内容
    //是否必填-否
    string pushContent=13;
}


message RecvCancelMsgEvent{
    //被撤销的消息发送方对应的sessionId
    //完整格式 联系人ID.Scene.设备ID
    //如 fromAccountId.C2C
    //如 fromAccountId.P2P.fromDeviceId
    //是否必填-是
    string fromSessionId=1;
    //被撤销的消息接收方对应的sessionId
    //完整格式 联系人ID.Scene.设备ID
    //如 toTeamId.C2G
    //是否必填-否
    string toSessionId=2;
    //要撤销的消息的由服务器分配的消息id
    //是否必填-是
    string idServer=3;
}

// 标记消息已读
message MarkMessageAckReq{
    //传输场景
    //C2C(1) - 点对点通讯
    //C2G(2) - 群组通讯
    //System(3) - 系统消息
    //是否必填-是
    MessageScene scene=1;
    //当次拉取到的最大的消息ID
    //是否必填-是
    string msgid=2;
    //当次拉取消息列表中，最大消息ID对应的time字段值
    //是否必填-是
    fixed64 timeTag=3;
}
message MarkMessageAckRsp
{

}


